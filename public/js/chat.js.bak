// Chat functionality using Socket.io
document.addEventListener('DOMContentLoaded', function() {
    // UI elements
    const messagesContainer = document.getElementById('messages');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-message');
    const mediaUploadButton = document.getElementById('media-upload');
    const mediaInput = document.getElementById('media-input');
    const emojiButton = document.getElementById('emoji-button');
    const emojiPicker = document.getElementById('emoji-picker');
    
    // Define global variables for grouping related messages
    let lastMessageSender = null;
    let lastMessageTime = null;
    let lastMessageWrapper = null;
    let replyToMessage = null;
    
    // Store pending messages during initial load
    let pendingMessages = [];
    
    // Get username from localStorage
    const username = localStorage.getItem('username');
    if (!username) {
        // Redirect to login if not logged in
        window.location.href = '/login';
    }
    
    // Socket.io connection
    const socket = io({
        auth: { 
            username: username
        }
    });
    
    // Update reactions for a message
    function updateReactions(messageElement, reactions) {
        // Find or create reactions container
        let reactionsContainer = messageElement.querySelector('.message-reactions');
        if (!reactionsContainer) {
            reactionsContainer = document.createElement('div');
            reactionsContainer.className = 'message-reactions';
            messageElement.appendChild(reactionsContainer);
        } else {
            // Clear existing reactions
            reactionsContainer.innerHTML = '';
        }
        
        // Group reactions by emoji
        const emojiCounts = {};
        reactions.forEach(reaction => {
            if (!emojiCounts[reaction.emoji]) {
                emojiCounts[reaction.emoji] = {
                    count: 0,
                    usernames: [],
                    userReacted: false
                };
            }
            emojiCounts[reaction.emoji].count++;
            
            const reactionUser = reaction.username || reaction.sender || 'Unknown';
            emojiCounts[reaction.emoji].usernames.push(reactionUser);
            
            // Check if current user reacted
            if (reactionUser === username) {
                emojiCounts[reaction.emoji].userReacted = true;
            }
        });
        
        // Create badge for each emoji
        for (const emoji in emojiCounts) {
            const badge = document.createElement('span');
            badge.className = 'reaction-badge';
            
            if (emojiCounts[emoji].userReacted) {
                badge.classList.add('user-reacted');
            }
            
            // Add emoji and count
            badge.innerHTML = `${emoji} <span class="reaction-count">${emojiCounts[emoji].count}</span>`;
            
            // Add click handler for adding/removing reactions
            badge.addEventListener('click', (e) => {
                e.stopPropagation();
                const messageId = messageElement.dataset.messageId;
                const alreadyReacted = emojiCounts[emoji].userReacted;
                
                if (alreadyReacted) {
                    // Remove reaction
                    socket.emit('remove reaction', {
                        messageId: messageId,
                        emoji: emoji
                    });
                } else {
                    // Add reaction
                    socket.emit('add reaction', {
                        messageId: messageId,
                        emoji: emoji
                    });
                }
            });
            
            reactionsContainer.appendChild(badge);
        }
        
        return reactionsContainer;
    }

    // Check if user is logged in
    const username = localStorage.getItem('username');
    if (!username) {
        window.location.href = '/login';
        return;
    }

    // Get DOM elements
    const messagesContainer = document.getElementById('messages');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-message');
    
    // For compatibility with both pages
    const attachmentButton = document.getElementById('attachment-btn') || document.getElementById('media-upload');
    const emojiButton = document.getElementById('emoji-btn') || document.getElementById('emoji-button');
    const fileInput = document.getElementById('file-input') || document.getElementById('media-input');
    const emojiPicker = document.getElementById('emoji-picker');
    
    // Keep track of the current reply-to message
    let replyToMessage = null;
    
    // Create a reaction menu element
    const reactionMenu = document.createElement('div');
    reactionMenu.className = 'reaction-menu';
    reactionMenu.innerHTML = `
        <div class="reaction-emoji-list">
            <span class="reaction-emoji" data-emoji="üëç">üëç</span>
            <span class="reaction-emoji" data-emoji="‚ù§Ô∏è">‚ù§Ô∏è</span>
            <span class="reaction-emoji" data-emoji="üòÇ">üòÇ</span>
            <span class="reaction-emoji" data-emoji="üòÆ">üòÆ</span>
            <span class="reaction-emoji" data-emoji="üò¢">üò¢</span>
            <span class="reaction-emoji" data-emoji="üëè">üëè</span>
            <span class="reaction-emoji" data-emoji="üî•">üî•</span>
            <span class="reaction-emoji" data-emoji="üôè">üôè</span>
        </div>
    `;
    document.body.appendChild(reactionMenu);
    
    // Add CSS for reply and reaction features
    const styleTag = document.createElement('style');
    styleTag.textContent = `
        .message-actions {
            display: none;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(30, 30, 40, 0.6);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            border-radius: 20px;
            padding: 4px 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 10;
            transition: all 0.2s ease;
            border: 1px solid rgba(242, 24, 217, 0.3);
            pointer-events: auto;
        }
        
        /* Show action buttons when hovering over message */
        .message:hover .message-actions {
            display: flex !important;
        }
        
        /* Specifically target consecutive messages to show actions on hover */
        .consecutive-message:hover .message-actions {
            display: flex !important;
        }
        
        /* Maintain visibility when hovering over the actions themselves */
        .message-actions:hover {
            display: flex !important;
        }
        
        .message-wrapper:hover .message-actions,
        .message-content:hover .message-actions {
            display: none;
        }
        
        /* Position for own messages - on the left side */
        .message-own .message-actions {
            left: -80px;
            right: auto;
        }
        
        /* Position for other users' messages - on the right side */
        .message-other .message-actions {
            right: -80px;
            left: auto;
        }
        
        /* Responsive adjustment for mobile */
        @media (max-width: 768px) {
            .message-own .message-actions {
                left: -70px;
            }
            
            .message-other .message-actions {
                right: -70px;
            }
        }
        
        /* For very small screens */
        @media (max-width: 480px) {
            .message-own .message-actions {
                left: -55px;
            }
            
            .message-other .message-actions {
                right: -55px;
            }
        }
        
        .action-button {
            background: transparent;
            border: none;
            color: rgba(242, 242, 242, 0.85);
            font-size: 14px;
            padding: 4px 8px;
            cursor: pointer;
            margin: 0 2px;
            border-radius: 15px;
            transition: all 0.2s;
        }
        
        .action-button:hover {
            background-color: rgba(242, 24, 217, 0.3);
            color: white;
            transform: scale(1.1);
            box-shadow: 0 0 8px rgba(242, 24, 217, 0.5);
        }
        
        .reply-container {
            background-color: rgba(30, 30, 40, 0.8);
            border-left: 3px solid #f218d9;
            padding: 6px 10px;
            margin-bottom: 6px;
            border-radius: 4px;
            font-size: 0.9em;
            position: relative;
        }
        
        .reply-username {
            color: #f218d9;
            font-weight: bold;
            margin-right: 5px;
        }
        
        .reply-text {
            color: #ccc;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 90%;
        }
        
        .reply-close {
            position: absolute;
            right: 5px;
            top: 5px;
            background: transparent;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 14px;
        }
        
        .reaction-menu {
            display: none;
            position: fixed;
            background-color: rgba(30, 30, 40, 0.95);
            border-radius: 20px;
            padding: 4px 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            border: 1px solid rgba(242, 24, 217, 0.3);
        }
        
        .reaction-emoji-list {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }
        
        .reaction-emoji {
            font-size: 18px;
            padding: 5px;
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 26px;
            height: 26px;
        }
        
        .reaction-emoji:hover {
            background-color: rgba(242, 24, 217, 0.3);
            transform: scale(1.2);
        }
        
        .message-reactions {
            display: flex;
            flex-wrap: wrap;
            margin-top: 4px;
            gap: 4px;
        }
        
        .reaction-badge {
            display: inline-flex;
            align-items: center;
            background-color: rgba(30, 30, 40, 0.8);
            border-radius: 12px;
            padding: 2px 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        
        .reaction-badge:hover {
            background-color: rgba(242, 24, 217, 0.2);
            border-color: rgba(242, 24, 217, 0.5);
        }
        
        .reaction-badge.user-reacted {
            background-color: rgba(242, 24, 217, 0.25);
            border-color: rgba(242, 24, 217, 0.5);
        }
        
        .reaction-count {
            margin-left: 2px;
            font-size: 11px;
            color: #ccc;
        }
        
        .reply-info {
            display: flex;
            align-items: center;
            background-color: rgba(30, 30, 40, 0.8);
            border-left: 3px solid #f218d9;
            padding: 5px 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            font-size: 0.85em;
            max-width: 90%;
        }
        
        .reply-avatar {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 5px;
            display: inline-block;
        }
        
        /* Message highlight animation */
        @keyframes highlightPulse {
            0% { background-color: rgba(242, 24, 217, 0); }
            25% { background-color: rgba(242, 24, 217, 0.3); }
            50% { background-color: rgba(242, 24, 217, 0.2); }
            75% { background-color: rgba(242, 24, 217, 0.15); }
            100% { background-color: rgba(242, 24, 217, 0); }
        }
        
        .highlight-message {
            animation: highlightPulse 2s ease;
            border-radius: 8px;
        }
        
        /* Position for consecutive messages */
        .consecutive-message {
            position: relative; /* Ensure consecutive messages have position relative */
        }
        
        /* For consecutive messages, maintain the same side positioning as regular messages */
        .consecutive-message.message-own .message-actions {
            left: -80px;
            right: auto;
            top: 50%;
            transform: translateY(-50%);
            position: absolute;
        }
        
        .consecutive-message.message-other .message-actions {
            right: -80px;
            left: auto;
            top: 50%;
            transform: translateY(-50%);
            position: absolute;
        }
    `;
    document.head.appendChild(styleTag);
    
    // Create reply indicator element (initially hidden)
    const replyIndicator = document.createElement('div');
    replyIndicator.id = 'reply-indicator';
    replyIndicator.className = 'reply-container';
    replyIndicator.style.display = 'none';
    replyIndicator.innerHTML = `
        <span class="reply-username"></span>
        <span class="reply-text"></span>
        <button class="reply-close"><i class="bi bi-x"></i></button>
    `;
    
    // Insert reply indicator before the input area
    const chatInputContainer = document.querySelector('.chat-input-container');
    chatInputContainer.parentNode.insertBefore(replyIndicator, chatInputContainer);
    
    // Add event listener for closing reply
    const replyCloseButton = replyIndicator.querySelector('.reply-close');
    replyCloseButton.addEventListener('click', function() {
        clearReply();
    });
    
    // Function to clear the current reply
    function clearReply() {
        replyToMessage = null;
        replyIndicator.style.display = 'none';
        replyIndicator.querySelector('.reply-username').textContent = '';
        replyIndicator.querySelector('.reply-text').textContent = '';
    }
    
    // Function to set up reply
    function setupReply(message) {
        replyToMessage = message;
        
        // Set the reply indicator content
        replyIndicator.querySelector('.reply-username').textContent = 
            message.username === username ? 'You' : (message.displayName || message.username);
        
        // Truncate text if it's too long
        let replyText = message.text || 'Media message';
        if (replyText.length > 50) {
            replyText = replyText.substring(0, 47) + '...';
        }
        
        replyIndicator.querySelector('.reply-text').textContent = replyText;
        replyIndicator.style.display = 'block';
        
        // Focus on message input
        messageInput.focus();
    }
    
    // Emoji categories and data
    const emojiCategories = {
        'smileys': ['üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÖ', 'üòÇ', 'ü§£', 'üòä', 'üòá', 'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞', 'üòò', 'üòó', 'üòô', 'üòö', 'üòã', 'üòõ', 'üòù', 'üòú', 'ü§™', 'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü•∏', 'ü§©', 'ü•≥', 'üòè', 'üòí', 'üòû', 'üòî', 'üòü', 'üòï', 'üôÅ', '‚òπÔ∏è', 'üò£', 'üòñ', 'üò´', 'üò©', 'ü•∫', 'üò¢', 'üò≠', 'üò§', 'üò†', 'üò°', 'ü§¨', 'ü§Ø', 'üò≥', 'ü•µ', 'ü•∂', 'üò±', 'üò®', 'üò∞', 'üò•', 'üòì', 'ü´£', 'ü§ó', 'ü´°', 'ü§î', 'ü´¢', 'ü§≠', 'ü§´', 'ü§•', 'üò∂', 'üòê', 'üòë', 'üò¨', 'ü´®', 'ü´†', 'üôÑ', 'üòØ', 'üò¶', 'üòß', 'üòÆ', 'üò≤', 'ü•±', 'üò¥', 'ü§§', 'üò™', 'üòµ', 'ü´•', 'ü§ê', 'ü•¥', 'ü§¢', 'ü§Æ', 'ü§ß', 'üò∑', 'ü§í', 'ü§ï', 'ü§ë', 'ü§†'],
        'people': ['üë∂', 'üëß', 'üßí', 'üë¶', 'üë©', 'üßë', 'üë®', 'üë©‚Äçü¶±', 'üë®‚Äçü¶±', 'üë©‚Äçü¶∞', 'üë®‚Äçü¶∞', 'üë±‚Äç‚ôÄÔ∏è', 'üë±‚Äç‚ôÇÔ∏è', 'üë©‚Äçü¶≥', 'üë®‚Äçü¶≥', 'üë©‚Äçü¶≤', 'üë®‚Äçü¶≤', 'üßî', 'üëµ', 'üßì', 'üë¥', 'üë≤', 'üë≥‚Äç‚ôÄÔ∏è', 'üë≥‚Äç‚ôÇÔ∏è', 'üßï', 'üëÆ‚Äç‚ôÄÔ∏è', 'üëÆ‚Äç‚ôÇÔ∏è', 'üë∑‚Äç‚ôÄÔ∏è', 'üë∑‚Äç‚ôÇÔ∏è', 'üíÇ‚Äç‚ôÄÔ∏è', 'üíÇ‚Äç‚ôÇÔ∏è', 'üïµÔ∏è‚Äç‚ôÄÔ∏è', 'üïµÔ∏è‚Äç‚ôÇÔ∏è', 'üë®‚Äç‚öïÔ∏è', 'üë©‚Äç‚öïÔ∏è', 'üë®‚Äçüåæ', 'üë©‚Äçüåæ', 'üë®‚Äçüç≥', 'üë©‚Äçüç≥', 'üë®‚Äçüéì', 'üë©‚Äçüéì', 'üë®‚Äçüé§', 'üë©‚Äçüé§', 'üë®‚Äçüè´', 'üë©‚Äçüè´', 'üë®‚Äçüè≠', 'üë©‚Äçüè≠', 'üë®‚Äçüíª', 'üë©‚Äçüíª', 'üë®‚Äçüíº', 'üë©‚Äçüíº', 'üë®‚Äçüîß', 'üë©‚Äçüîß', 'üë®‚Äçüî¨', 'üë©‚Äçüî¨', 'üë®‚Äçüé®', 'üë©‚Äçüé®', 'üë®‚ÄçüöÄ', 'üë©‚ÄçüöÄ', 'üë®‚Äç‚öñÔ∏è', 'üë®‚Äç‚öñÔ∏è', 'üë∞‚Äç‚ôÄÔ∏è', 'üë∞‚Äç‚ôÇÔ∏è', 'ü§µ‚Äç‚ôÄÔ∏è', 'ü§µ‚Äç‚ôÇÔ∏è', 'ü´É', 'ü´Ñ', 'ü§∞', 'ü§±', 'üëº', 'üéÖ', 'ü§∂', 'ü¶∏‚Äç‚ôÄÔ∏è', 'ü¶∏‚Äç‚ôÇÔ∏è', 'ü¶π‚Äç‚ôÄÔ∏è', 'ü¶π‚Äç‚ôÇÔ∏è', 'üßô‚Äç‚ôÄÔ∏è', 'üßô‚Äç‚ôÇÔ∏è', 'üßö‚Äç‚ôÄÔ∏è', 'üßö‚Äç‚ôÇÔ∏è', 'üßö‚Äç‚ôÄÔ∏è', 'üßõ‚Äç‚ôÇÔ∏è', 'üßú‚Äç‚ôÄÔ∏è', 'üßú‚Äç‚ôÇÔ∏è', 'üßù‚Äç‚ôÄÔ∏è', 'üßù‚Äç‚ôÇÔ∏è', 'üßû‚Äç‚ôÄÔ∏è', 'üßû‚Äç‚ôÇÔ∏è', 'üßü‚Äç‚ôÄÔ∏è', 'üßü‚Äç‚ôÇÔ∏è', 'üßå', 'üíÜ‚Äç‚ôÄÔ∏è', 'üíÜ‚Äç‚ôÇÔ∏è', 'üíá‚Äç‚ôÄÔ∏è', 'üíá‚Äç‚ôÇÔ∏è', 'üö∂‚Äç‚ôÄÔ∏è', 'üö∂‚Äç‚ôÇÔ∏è', 'üßç‚Äç‚ôÄÔ∏è', 'üßç‚Äç‚ôÇÔ∏è', 'üßé‚Äç‚ôÄÔ∏è', 'üßé‚Äç‚ôÇÔ∏è', 'üèÉ‚Äç‚ôÄÔ∏è', 'üèÉ‚Äç‚ôÇÔ∏è', 'üíÉ', 'üï∫', 'üëØ‚Äç‚ôÄÔ∏è', 'üëØ‚Äç‚ôÇÔ∏è', 'üßñ‚Äç‚ôÄÔ∏è', 'üßñ‚Äç‚ôÇÔ∏è', 'üßó‚Äç‚ôÄÔ∏è', 'üßó‚Äç‚ôÇÔ∏è', 'ü§∫', 'üèá', '‚õ∑Ô∏è', 'üèÇ', 'üèåÔ∏è‚Äç‚ôÄÔ∏è', 'üèåÔ∏è‚Äç‚ôÇÔ∏è', 'üèÑ‚Äç‚ôÄÔ∏è', 'üèÑ‚Äç‚ôÇÔ∏è', 'üö£‚Äç‚ôÄÔ∏è', 'üö£‚Äç‚ôÇÔ∏è', 'üèä‚Äç‚ôÄÔ∏è', 'üèä‚Äç‚ôÇÔ∏è', '‚õπÔ∏è‚Äç‚ôÄÔ∏è', '‚õπÔ∏è‚Äç‚ôÇÔ∏è', 'üèãÔ∏è‚Äç‚ôÄÔ∏è', 'üèãÔ∏è‚Äç‚ôÇÔ∏è', 'üö¥‚Äç‚ôÄÔ∏è', 'üö¥‚Äç‚ôÇÔ∏è', 'üöµ‚Äç‚ôÄÔ∏è', 'üöµ‚Äç‚ôÇÔ∏è', 'ü§∏‚Äç‚ôÄÔ∏è', 'ü§∏‚Äç‚ôÇÔ∏è', 'ü§º‚Äç‚ôÄÔ∏è', 'ü§º‚Äç‚ôÇÔ∏è', 'ü§Ω‚Äç‚ôÄÔ∏è', 'ü§Ω‚Äç‚ôÇÔ∏è', 'ü§æ‚Äç‚ôÄÔ∏è', 'ü§æ‚Äç‚ôÇÔ∏è', 'ü§π‚Äç‚ôÄÔ∏è', 'ü§π‚Äç‚ôÇÔ∏è', 'üßò‚Äç‚ôÄÔ∏è', 'üßò‚Äç‚ôÇÔ∏è', 'üõÄ', 'üõå'],
        'gestures': ['üëã', 'ü§ö', 'üñêÔ∏è', '‚úã', 'üññ', 'üëå', 'ü§å', 'ü§è', '‚úåÔ∏è', 'ü§û', 'ü´∞', 'ü§ü', 'ü§ò', 'ü§ô', 'üëà', 'üëâ', 'üëÜ', 'üñï', 'üëá', '‚òùÔ∏è', 'üëç', 'üëé', '‚úä', 'üëä', 'ü§õ', 'ü§ú', 'üëè', 'üôå', 'üëê', 'ü§≤', 'ü§ù', 'üôè', '‚úçÔ∏è', 'üíÖ', 'ü§≥', 'üí™', 'ü¶æ', 'ü¶ø', 'ü¶µ', 'ü¶∂', 'üëÇ', 'ü¶ª', 'üëÉ', 'üß†', 'ü´Ä', 'ü´Å', 'ü¶∑', 'ü¶¥', 'üëÄ', 'üëÅÔ∏è', 'üëÖ', 'üëÑ', 'ü´¶', 'üíã', 'ü©∫'],
        'love': ['üíò', 'üíù', 'üíñ', 'üíó', 'üíì', 'üíû', 'üíï', 'üíü', '‚ù£Ô∏è', 'üíî', '‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'ü§é', 'üñ§', 'ü§ç', 'üíØ', 'üí¢', 'üí•', 'üí´', 'üí¶', 'üí®', 'üï≥Ô∏è', 'üí£', 'üí¨', 'üëÅÔ∏è‚Äçüó®Ô∏è', 'üó®Ô∏è', 'üóØÔ∏è', 'üí≠', 'üí§'],
        'animals': ['üêµ', 'üêí', 'ü¶ç', 'ü¶ß', 'üê∂', 'üêï', 'ü¶Æ', 'üêï‚Äçü¶∫', 'üê©', 'üê∫', 'ü¶ä', 'ü¶ù', 'üê±', 'üêà', 'üêà‚Äç‚¨õ', 'ü¶Å', 'üêØ', 'üêÖ', 'üêÜ', 'üê¥', 'üêé', 'ü¶Ñ', 'ü¶ì', 'ü¶å', 'ü¶¨', 'üêÆ', 'üêÇ', 'üêÉ', 'üêÑ', 'üê∑', 'üêñ', 'üêó', 'üêΩ', 'üêè', 'üêë', 'üêê', 'üê™', 'üê´', 'ü¶ô', 'ü¶í', 'üêò', 'ü¶£', 'ü¶è', 'ü¶õ', 'üê≠', 'üêÅ', 'üêÄ', 'üêπ', 'üê∞', 'üêá', 'üêøÔ∏è', 'ü¶´', 'ü¶î', 'ü¶á', 'üêª', 'üêª‚Äç‚ùÑÔ∏è', 'üê®', 'üêº', 'ü¶•', 'ü¶¶', 'ü¶®', 'ü¶ò', 'ü¶°', 'üêæ', 'ü¶É', 'üêî', 'üêì', 'üê£', 'üê§', 'üê•', 'üê¶', 'üêß', 'üïäÔ∏è', 'ü¶Ö', 'ü¶Ü', 'ü¶¢', 'ü¶â', 'ü¶§', 'ü™∂', 'ü¶©', 'ü¶ö', 'ü¶ú', 'üê∏', 'üêä', 'üê¢', 'ü¶é', 'üêç', 'üê≤', 'üêâ', 'ü¶ï', 'ü¶ñ', 'üê≥', 'üêã', 'üê¨', 'ü¶≠', 'üêü', 'üê†', 'üê°', 'ü¶à', 'üêô', 'üêö', 'ü™∏', 'üêå', 'ü¶ã', 'üêõ', 'üêú', 'üêù', 'ü™≤', 'üêû', 'ü¶ó', 'ü™≥', 'üï∑Ô∏è', 'üï∏Ô∏è', 'ü¶Ç', 'ü¶ü', 'ü™∞', 'ü™±', 'ü¶†'],
        'nature': ['üå∏', 'üíÆ', 'üèµÔ∏è', 'üåπ', 'ü•Ä', 'üå∫', 'üåª', 'üåº', 'üå∑', 'üå±', 'ü™¥', 'üå≤', 'üå≥', 'üå¥', 'üåµ', 'üåæ', 'üåø', '‚òòÔ∏è', 'üçÄ', 'üçÅ', 'üçÇ', 'üçÉ', 'ü™π', 'ü™∫', 'üçá', 'üçà', 'üçâ', 'üçä', 'üçã', 'üçå', 'üçç', 'ü•≠', 'üçé', 'üçè', 'üçê', 'üçë', 'üçí', 'üçì', 'ü´ê', 'ü•ù', 'üçÖ', 'ü´í', 'ü••', 'ü•ë', 'üçÜ', 'ü•î', 'ü•ï', 'üåΩ', 'üå∂Ô∏è', 'ü´ë', 'ü•í', 'ü•¨', 'ü•¶', 'üßÑ', 'üßÖ', 'üçÑ', 'ü•ú', 'ü´ò', 'üå∞'],
        'food': ['üçû', 'ü•ê', 'ü•ñ', 'ü´ì', 'ü•®', 'ü•Ø', 'ü•û', 'üßá', 'üßÄ', 'üçñ', 'üçó', 'ü•©', 'ü•ì', 'üçî', 'üçü', 'üçï', 'üå≠', 'ü•™', 'üåÆ', 'üåØ', 'ü´î', 'ü•ô', 'üßÜ', 'ü•ö', 'üç≥', 'ü•ò', 'üç≤', 'ü´ï', 'ü•£', 'ü•ó', 'üçø', 'üßà', 'üßÇ', 'ü•´', 'üç±', 'üçò', 'üçô', 'üçö', 'üçõ', 'üçú', 'üçù', 'üç†', 'üç¢', 'üç£', 'üç§', 'üç•', 'ü•Æ', 'üç°', 'ü•ü', 'ü•†', 'ü•°', 'ü¶Ä', 'ü¶û', 'ü¶ê', 'ü¶ë', 'ü¶™', 'üç¶', 'üçß', 'üç®', 'üç©', 'üç™', 'üéÇ', 'üç∞', 'üßÅ', 'ü•ß', 'üç´', 'üç¨', 'üç≠', 'üçÆ', 'üçØ', 'üçº', 'ü•õ', '‚òï', 'ü´ñ', 'üçµ', 'üç∂', 'üçæ', 'üç∑', 'üç∏', 'üçπ', 'üç∫', 'üçª', 'ü•Ç', 'ü•É', 'ü´ó', 'ü•§', 'üßã', 'üßÉ', 'üßâ', 'üßä'],
        'activities': ['üé™', 'ü§π', 'üé≠', 'ü©∞', 'üé®', 'üé¨', 'üé§', 'üéß', 'üéº', 'üéπ', 'ü•Å', 'ü™ò', 'üé∑', 'üé∫', 'ü™ó', 'üé∏', 'ü™ï', 'üéª', 'üé≤', '‚ôüÔ∏è', 'üéØ', 'üé≥', 'üéÆ', 'üé∞', 'üß©', 'üé™', 'üé≠', 'üñºÔ∏è', 'üé®', 'üßµ', 'ü™°', 'üß∂', 'ü™¢'],
        'travel': ['üöó', 'üöï', 'üöô', 'üöå', 'üöé', 'üèéÔ∏è', 'üöì', 'üöë', 'üöí', 'üöê', 'üõª', 'üöö', 'üöõ', 'üöú', 'üõµ', 'üèçÔ∏è', 'üõ∫', 'üö≤', 'üõ¥', 'üõπ', 'üõº', 'üöÇ', 'üöÉ', 'üöÑ', 'üöÖ', 'üöÜ', 'üöá', 'üöà', 'üöâ', 'üöä', 'üöù', 'üöû', 'üöã', 'üöå', 'üöç', 'üöé', 'üöê', 'üöë', 'üöí', 'üöì', 'üöî', 'üöï', 'üöñ', 'üöó', 'üöò', 'üöô', 'üöö', 'üöõ', 'üöú', 'üõ¥', 'üö≤', 'üõµ', 'üèçÔ∏è', 'üõ∫', 'üö®', 'üö•', 'üö¶', 'üõë', 'üöß'],
        'objects': ['‚åö', 'üì±', 'üì≤', 'üíª', '‚å®Ô∏è', 'üñ•Ô∏è', 'üñ®Ô∏è', 'üñ±Ô∏è', 'üñ≤Ô∏è', 'üïπÔ∏è', 'üóúÔ∏è', 'üíΩ', 'üíæ', 'üíø', 'üìÄ', 'üìº', 'üì∑', 'üì∏', 'üìπ', 'üé•', 'üìΩÔ∏è', 'üéûÔ∏è', 'üìû', '‚òéÔ∏è', 'üìü', 'üì†', 'üì∫', 'üìª', 'üéôÔ∏è', 'üéöÔ∏è', 'üéõÔ∏è', 'üß≠', '‚è±Ô∏è', '‚è≤Ô∏è', '‚è∞', 'üï∞Ô∏è', '‚åõ', '‚è≥', 'üì°', 'üîã', 'üîå', 'üí°', 'üî¶', 'üïØÔ∏è', 'ü™î', 'üßØ', 'üõ¢Ô∏è', 'üí∏', 'üíµ', 'üí¥', 'üí∂', 'üí∑', 'ü™ô', 'üí∞', 'üí≥', 'üíé', '‚öñÔ∏è', 'ü™ú', 'üß∞', 'ü™õ', 'üîß', 'üî®', '‚öíÔ∏è', 'üõ†Ô∏è', '‚õèÔ∏è', 'ü™ö', 'üî©', '‚öôÔ∏è', 'ü™§', 'üß±', '‚õìÔ∏è', 'üß≤', 'üî´', 'üí£', 'üß®', 'ü™ì', 'üî™', 'üó°Ô∏è', '‚öîÔ∏è', 'üõ°Ô∏è', 'üö¨', '‚ö∞Ô∏è', '‚ö±Ô∏è', 'üè∫', 'üîÆ', 'üìø', 'üßø', 'üíà', '‚öóÔ∏è', 'üî≠', 'üî¨', 'üï≥Ô∏è', 'ü©π', 'ü©∫', 'üíä', 'üíâ', 'ü©∏', 'üß¨', 'ü¶†', 'üß´', 'üß™', 'üå°Ô∏è', 'üßπ', 'ü™†', 'üß∫', 'üßª', 'üöΩ', 'üö∞', 'üöø', 'üõÅ', 'üõÄ', 'üßº', 'ü™•', 'ü™í', 'üßΩ', 'ü™£', 'üß¥', 'üõéÔ∏è', 'üîë', 'üóùÔ∏è', 'üö™', 'ü™ë', 'üõãÔ∏è', 'üõèÔ∏è', 'üõå', 'üß∏', 'ü™Ü', 'üñºÔ∏è', 'ü™û', 'ü™ü', 'üõçÔ∏è', 'üõí', 'üéÅ', 'üéà', 'üéè', 'üéÄ', 'ü™Ñ', 'ü™Ö', 'üéä', 'üéâ', 'üéé', 'üèÆ', 'üéê', 'üßß', '‚úâÔ∏è', 'üì©', 'üì®', 'üìß', 'üíå', 'üì•', 'üì§', 'üì¶', 'üè∑Ô∏è', 'üì™', 'üì´', 'üì¨', 'üì≠', 'üìÆ', 'üìØ', 'üìú', 'üìÉ', 'üìÑ', 'üìë', 'üßæ', 'üìä', 'üìà', 'üìâ', 'üóíÔ∏è', 'üóìÔ∏è', 'üìÜ', 'üìÖ', 'üóëÔ∏è', 'üìá', 'üóÉÔ∏è', 'üó≥Ô∏è', 'üóÑÔ∏è', 'üìã', 'üìÅ', 'üìÇ', 'üóÇÔ∏è', 'üóûÔ∏è', 'üì∞', 'üìì', 'üìî', 'üìí', 'üìï', 'üìó', 'üìò', 'üìô', 'üìö', 'üìñ', 'üîñ', 'üß∑', 'üîó', 'üìé', 'üñáÔ∏è', 'üìê', 'üìè', 'üßÆ', 'üìå', 'üìç', '‚úÇÔ∏è', 'üñäÔ∏è', 'üñãÔ∏è', '‚úíÔ∏è', 'üñåÔ∏è', 'üñçÔ∏è', 'üìù', '‚úèÔ∏è', 'üîç', 'üîé', 'üîè', 'üîê', 'üîí', 'üîì'],
        'symbols': ['‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç', 'ü§é', 'üíî', '‚ù£Ô∏è', 'üíï', 'üíû', 'üíì', 'üíó', 'üíñ', 'üíò', 'üíù', 'üíü', '‚òÆÔ∏è', '‚úùÔ∏è', '‚ò™Ô∏è', 'üïâÔ∏è', '‚ò∏Ô∏è', '‚ú°Ô∏è', 'üîØ', 'üïé', '‚òØÔ∏è', '‚ò¶Ô∏è', 'üõê', '‚õé', '‚ôà', '‚ôâ', '‚ôä', '‚ôã', '‚ôå', '‚ôç', '‚ôé', '‚ôè', '‚ôê', '‚ôë', '‚ôí', '‚ôì', 'üÜî', '‚öõÔ∏è', 'üâë', '‚ò¢Ô∏è', '‚ò£Ô∏è', 'üì¥', 'üì≥', 'üà∂', 'üàö', 'üà∏', 'üà∫', 'üà∑Ô∏è', '‚ú¥Ô∏è', 'üÜö', 'üíÆ', 'üâê', '„äôÔ∏è', '„äóÔ∏è', 'üà¥', 'üàµ', 'üàπ', 'üà≤', 'üÖ∞Ô∏è', 'üÖ±Ô∏è', 'üÜé', 'üÜë', 'üÖæÔ∏è', 'üÜò', '‚ùå', '‚≠ï', 'üõë', '‚õî', 'üìõ', 'üö´', 'üíØ', 'üí¢', '‚ô®Ô∏è', 'üö∑', 'üöØ', 'üö≥', 'üö±', 'üîû', 'üìµ', 'üö≠', '‚ùó', '‚ùï', '‚ùì', '‚ùî', '‚ÄºÔ∏è', '‚ÅâÔ∏è', 'üîÖ', 'üîÜ', '„ÄΩÔ∏è', '‚ö†Ô∏è', 'üö∏', 'üî±', '‚öúÔ∏è', 'üî∞', '‚ôªÔ∏è', '‚úÖ', 'üàØ', 'üíπ', '‚ùáÔ∏è', '‚ú≥Ô∏è', '‚ùé', 'üåê', 'üí†', '‚ìÇÔ∏è', 'üåÄ', 'üí§', 'üèß', 'üöæ', '‚ôø', 'üÖøÔ∏è', 'üõó', 'üà≥', 'üàÇÔ∏è', 'üõÇ', 'üõÉ', 'üõÑ', 'üõÖ', 'üöπ', 'üö∫', 'üöº', '‚öß', 'üöª', 'üöÆ', 'üé¶', 'üì∂', 'üàÅ', 'üî£', '‚ÑπÔ∏è', 'üî§', 'üî°', 'üî†', 'üÜñ', 'üÜó', 'üÜô', 'üÜí', 'üÜï', 'üÜì', '0Ô∏è‚É£', '1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£', '4Ô∏è‚É£', '5Ô∏è‚É£', '6Ô∏è‚É£', '7Ô∏è‚É£', '8Ô∏è‚É£', '9Ô∏è‚É£', 'üîü', 'üî¢', '#Ô∏è‚É£', '*Ô∏è‚É£', '‚èèÔ∏è', '‚ñ∂Ô∏è', '‚è∏Ô∏è', '‚èØÔ∏è', '‚èπÔ∏è', '‚è∫Ô∏è', '‚è≠Ô∏è', '‚èÆÔ∏è', '‚è©', '‚è™', '‚è´', '‚è¨', '‚óÄÔ∏è', 'üîº', 'üîΩ', '‚û°Ô∏è', '‚¨ÖÔ∏è', '‚¨ÜÔ∏è', '‚¨áÔ∏è', '‚ÜóÔ∏è', '‚ÜòÔ∏è', '‚ÜôÔ∏è', '‚ÜñÔ∏è', '‚ÜïÔ∏è', '‚ÜîÔ∏è', '‚Ü™Ô∏è', '‚Ü©Ô∏è', '‚§¥Ô∏è', '‚§µÔ∏è', 'üîÄ', 'üîÅ', 'üîÇ', 'üîÑ', 'üîÉ', 'üéµ', 'üé∂', '‚ûï', '‚ûñ', '‚ûó', '‚úñÔ∏è', '‚ôæÔ∏è', 'üí≤', 'üí±', '‚Ñ¢Ô∏è', '¬©Ô∏è', '¬ÆÔ∏è', '„Ä∞Ô∏è', '‚û∞', '‚ûø', 'üîö', 'üîô', 'üîõ', 'üîù', 'üîú', '‚úîÔ∏è', '‚òëÔ∏è', 'üîò', 'üî¥', 'üü†', 'üü°', 'üü¢', 'üîµ', 'üü£', '‚ö´', '‚ö™', 'üü§', 'üî∫', 'üîª', 'üî∏', 'üîπ', 'üî∂', 'üî∑', 'üî≥', 'üî≤', '‚ñ™Ô∏è', '‚ñ´Ô∏è', '‚óæ', '‚óΩ', '‚óºÔ∏è', '‚óªÔ∏è', 'üü•', 'üüß', 'üü®', 'üü©', 'üü¶', 'üü™', '‚¨õ', '‚¨ú', 'üü´', 'üîà', 'üîá', 'üîâ', 'üîä', 'üîî', 'üîï', 'üì£', 'üì¢', 'üí¨', 'üí≠', 'üóØÔ∏è', '‚ô†Ô∏è', '‚ô£Ô∏è', '‚ô•Ô∏è', '‚ô¶Ô∏è', 'üÉè', 'üé¥', 'üÄÑ', 'üïê', 'üïë', 'üïí', 'üïì', 'üïî', 'üïï', 'üïñ', 'üïó', 'üïò', 'üïô', 'üïö', 'üïõ', 'üïú', 'üïù', 'üïû', 'üïü', 'üï†', 'üï°', 'üï¢', 'üï£', 'üï§', 'üï•', 'üï¶', 'üïß']
    };

    // Category icons for tabs
    const categoryIcons = {
        'smileys': 'üòä',
        'people': 'üë•',
        'gestures': 'üëã',
        'love': '‚ù§Ô∏è',
        'animals': 'üê±',
        'nature': 'üå∏',
        'food': 'üçî',
        'activities': '‚öΩ',
        'travel': '‚úàÔ∏è',
        'objects': 'üí°',
        'symbols': 'üí†'
    };

    // Add auto-resize functionality to the message input
    messageInput.addEventListener('input', function() {
        // Reset height to auto to get the right scrollHeight
        this.style.height = 'auto';
        // Set new height based on content (with a max)
        const newHeight = Math.min(this.scrollHeight, 120);
        this.style.height = newHeight + 'px';
    });
    
    // Track last message sender for grouping
    let lastMessageSender = null;
    let lastMessageTime = null;
    let lastMessageWrapper = null;
    
    // Connect to Socket.io with username from localStorage
    const socket = io({
        auth: { 
            username: username
        }
    });

    // Store incoming messages until we're ready to display them
    let pendingMessages = [];
    let initialLoadComplete = false;
    
    // Track online users
    const onlineUsers = new Set();

    // Handle connection
    socket.on('connect', () => {
        console.log('Connected to chat server');
        
        // Reset message container and add loading indicator
        messagesContainer.innerHTML = `
            <div class="loading-messages">
                <div class="loading-spinner">
                    <i class="bi bi-arrow-repeat"></i> Loading messages...
                </div>
            </div>
        `;
        
        // Reset variables for new connection
        pendingMessages = [];
        initialLoadComplete = false;
        
        // Add a class to force scroll position to bottom without animation
        messagesContainer.classList.add('loading-messages-no-scroll');
        
        // Start sending heartbeats every minute to keep online status
        setInterval(() => {
            socket.emit('heartbeat');
        }, 60 * 1000); // every minute
    });

    // Handle connection errors
    socket.on('connect_error', (error) => {
        console.error('Connection error:', error);
        notifications.error('Connection Error', 'Failed to connect to chat server');
    });

    // Handle incoming messages
    socket.on('chat message', (msg) => {
        // Log for debugging
        console.log(`Received message with ID: ${msg._id || 'undefined'}`);
        
        // If we're still loading initial messages, store this for later
        if (!initialLoadComplete) {
            pendingMessages.push({type: 'chat', data: msg});
            return;
        }
        
        // Otherwise add the message immediately (normal case)
        addMessage(msg);
    });

    // Handle disconnection
    socket.on('disconnect', () => {
        console.log('Disconnected from chat server');
        // Reset message grouping on disconnect
        lastMessageSender = null;
        lastMessageTime = null;
        lastMessageWrapper = null;
    });

    // Handle system messages from server
    socket.on('system message', (data) => {
        // System messages break the conversation flow
        lastMessageSender = null;
        lastMessageTime = null;
        lastMessageWrapper = null;
        
        // If we're still loading initial messages, store this for later
        if (!initialLoadComplete) {
            pendingMessages.push({type: 'system', data});
            return;
        }
        
        addSystemMessage(data.text);
    });

    // Handle online users list
    socket.on('online users', (users) => {
        console.log('Received online users list with', users.length, 'users');
        onlineUsers.clear();
        users.forEach(user => onlineUsers.add(user));
        
        // Update message containers with online status
        updateOnlineStatusInMessages();
    });
    
    // Handle user status updates
    socket.on('user status', (data) => {
        console.log('User status update:', data.username, data.status);
        
        if (data.status === 'online') {
            onlineUsers.add(data.username);
        } else {
            onlineUsers.delete(data.username);
        }
        
        // Update message containers for this specific user
        updateOnlineStatusInMessages(data.username);
    });

    // Once we have all the messages, display them
    socket.on('history complete', () => {
        console.log(`Received ${pendingMessages.length} historical messages`);
        
        // Clear loading indicator
        messagesContainer.innerHTML = '';
        
        // Process all pending messages
        for (const item of pendingMessages) {
            if (item.type === 'chat') {
                addMessage(item.data);
            } else if (item.type === 'system') {
                addSystemMessage(item.data.text);
            }
        }
        
        // Mark initial load as complete
        initialLoadComplete = true;
        
        // Clear the pending messages
        pendingMessages = [];
        
        // Scroll to bottom without animation
        scrollToBottom(false);
        
        console.log('Chat history loaded and displayed');
    });

    // Send message when button is clicked
    sendButton.addEventListener('click', sendMessage);

    // Send message when Enter key is pressed (without Shift)
    messageInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });

    // Function to send a message
    function sendMessage() {
        const messageText = messageInput.value.trim();
        if (messageText || replyToMessage) { // Allow empty message if it's a reply
            // Create the message data
            const messageData = { text: messageText };
            
            // Add reply information if replying to a message
            if (replyToMessage) {
                messageData.replyTo = {
                    messageId: replyToMessage._id,
                    text: replyToMessage.text,
                    username: replyToMessage.username,
                    timestamp: replyToMessage.timestamp
                };
            }
            
            // Send the message to the server
            socket.emit('chat message', messageData);
            
            // Clear input field and reset its size
            messageInput.value = '';
            messageInput.style.height = 'auto';
            
            // Clear reply if any
            clearReply();
            
            // Focus on input field
            messageInput.focus();
        }
    }

    // Function to check if messages should be grouped
    function shouldGroupMessages(currentSender, currentTime) {
        // If no previous message or different sender, don't group
        if (!lastMessageSender || lastMessageSender !== currentSender) {
            return false;
        }
        
        // Check if messages are within 2 minutes of each other
        if (currentTime && lastMessageTime) {
            const timeDiff = Math.abs(new Date(currentTime) - new Date(lastMessageTime));
            const twoMinutesInMs = 2 * 60 * 1000;
            return timeDiff < twoMinutesInMs;
        }
        
        return true;
    }

    // Function to check if a message is short (for styling)
    function isShortMessage(text) {
        if (!text) return true;
        // Messages with 25 or fewer characters are considered "short"
        return text.length <= 25 && !text.includes('\n');
    }

    // Function to format message text for display
    function formatMessageText(text) {
        // Use the new function that preserves emoticons and handles line breaks
        return sanitizeWithEmoticonsAndLineBreaks(text);
    }

    // Function to add a message to the chat
    function addMessage(msg, noScroll = false) {
        // Log message data for debugging
        console.log(`Adding message to DOM, ID: ${msg._id || 'undefined'}`);
        
        const currentSender = msg.username;
        const currentTime = msg.timestamp;
        const isOwnMessage = currentSender === username;
        const messageText = msg.text || '';
        
        // Ensure message has a consistent ID
        if (!msg._id && msg.id) {
            msg._id = msg.id;
        } else if (!msg.id && msg._id) {
            msg.id = msg._id;
        }
        
        // Check if this message should be grouped with the previous one
        if (shouldGroupMessages(currentSender, currentTime) && lastMessageWrapper) {
            const messageElement = document.createElement('div');
            messageElement.className = 'message ' + 
                (isOwnMessage ? 'message-own' : 'message-other') + ' consecutive-message';
            messageElement.dataset.messageId = msg._id || msg.id;
            
            // Check if message is short to apply special styling
            if (isShortMessage(messageText)) {
                messageElement.classList.add('short-message');
            }
            
            // Create message actions if function exists
            if (typeof createMessageActions === 'function') {
                const actionsDiv = createMessageActions(messageElement, msg);
                messageElement.appendChild(actionsDiv);
            }
            
            const textSpan = document.createElement('span');
            textSpan.className = 'message-text';
            
            // Check if this is a reply message
            if (msg.replyTo && (msg.replyTo.messageId || msg.replyTo.id)) {
                const replyToId = msg.replyTo.messageId || msg.replyTo.id;
                
                const replyInfo = document.createElement('div');
                replyInfo.className = 'reply-info';
                replyInfo.dataset.replyToId = replyToId;
                
                // Add click event to scroll to original message
                replyInfo.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Reply clicked, target ID:', replyToId);
                    if (typeof scrollToOriginalMessage === 'function') {
                        scrollToOriginalMessage(replyToId);
                    }
                });
                
                // Add a reply icon
                const replyIcon = document.createElement('span');
                replyIcon.className = 'reply-icon';
                replyIcon.innerHTML = '‚Ü© ';
                replyIcon.style.color = '#f218d9';
                replyIcon.style.marginRight = '4px';
                replyIcon.style.fontWeight = 'bold';
                replyInfo.appendChild(replyIcon);
                
                const replyUsername = document.createElement('span');
                replyUsername.className = 'reply-username';
                replyUsername.textContent = msg.replyTo.username || "Unknown user";
                
                const replyText = document.createElement('span');
                replyText.className = 'reply-text';
                replyText.textContent = msg.replyTo.text || 'Media message';
                
                replyInfo.appendChild(replyUsername);
                replyInfo.appendChild(replyText);
                textSpan.appendChild(replyInfo);
                
                messageElement.dataset.isReply = "true";
                messageElement.classList.add('has-reply');
            }
            
            // Handle media if present and valid
            if (msg.media && typeof msg.media === 'object' && msg.media.url) {
                const mediaElement = createMediaElement(msg.media);
                if (mediaElement) {
                    textSpan.appendChild(mediaElement);
                }
            }
            
            // Add text if present
            if (msg.text && msg.text.trim()) {
                const textNode = document.createElement('span');
                textNode.innerHTML = formatMessageText(msg.text);
                textSpan.appendChild(textNode);
            }
            
            // Add timestamp
            const timeElement = document.createElement('span');
            timeElement.className = 'message-time';
            timeElement.textContent = formatTime(new Date(currentTime));
            textSpan.appendChild(timeElement);
            
            // Add text content
            messageElement.appendChild(textSpan);
            
            // Add reactions if present
            if (msg.reactions && msg.reactions.length > 0) {
                if (typeof updateReactions === 'function') {
                    updateReactions(messageElement, msg.reactions);
                } else if (typeof window.updateReactions === 'function') {
                    window.updateReactions(messageElement, msg.reactions);
                }
            }
            
            const messageContent = lastMessageWrapper.querySelector('.message-content');
            messageContent.appendChild(messageElement);
            
            lastMessageTime = currentTime;
            
            // Only scroll if needed
            if (!noScroll) {
                scrollToBottom();
            }
            return;
        }
        
        // Create new message container for non-consecutive messages
        const messageContainer = document.createElement('div');
        messageContainer.className = 'message-container';
        messageContainer.dataset.username = currentSender;
        
        const messageWrapper = document.createElement('div');
        messageWrapper.className = isOwnMessage ? 'message-wrapper own' : 'message-wrapper';
        messageWrapper.dataset.messageId = msg._id || msg.id;
        
        const profilePic = document.createElement('div');
        profilePic.className = 'message-profile-pic';
        
        const profilePicLink = document.createElement('a');
        profilePicLink.href = isOwnMessage ? '/profile' : `/user/${currentSender}`;
        profilePicLink.title = `View ${isOwnMessage ? 'your' : `${currentSender}'s`} profile`;
        
        const profileImg = document.createElement('img');
        profileImg.src = isOwnMessage 
            ? (document.getElementById('navProfilePic')?.src || '/images/default-profile.png') 
            : (msg.profilePic || '/images/default-profile.png');
        profileImg.alt = isOwnMessage ? 'You' : (msg.displayName || currentSender);
        profileImg.loading = 'lazy';
        
        profilePicLink.appendChild(profileImg);
        profilePic.appendChild(profilePicLink);
        
        const messageContent = document.createElement('div');
        messageContent.className = 'message-content';
        
        const header = document.createElement('div');
        header.className = 'message-header';
        
        const sender = document.createElement('a');
        sender.className = 'message-sender';
        sender.textContent = isOwnMessage ? 'You' : (msg.displayName || currentSender);
        sender.href = isOwnMessage ? '/profile' : `/user/${currentSender}`;
        sender.title = `View ${isOwnMessage ? 'your' : `${msg.displayName || currentSender}'s`} profile`;
        
        // Add timestamp in the header
        let timestamp;
        if (currentTime) {
            timestamp = document.createElement('span');
            timestamp.className = 'message-time';
            timestamp.textContent = formatTime(new Date(currentTime));
            header.appendChild(sender);
            header.appendChild(timestamp);
        } else {
            header.appendChild(sender);
        }
        
        messageContent.appendChild(header);
        
        // Create the first message in this container
        const messageElement = document.createElement('div');
        messageElement.className = 'message ' + (isOwnMessage ? 'message-own' : 'message-other');
        messageElement.dataset.messageId = msg._id || msg.id;
        
        // Check if message is short
        if (isShortMessage(messageText)) {
            messageElement.classList.add('short-message');
        }
        
        // Create message actions if function exists
        if (typeof createMessageActions === 'function') {
            const actionsDiv = createMessageActions(messageElement, msg);
            messageElement.appendChild(actionsDiv);
        }
        
        const textSpan = document.createElement('span');
        textSpan.className = 'message-text';
        
        // Handle reply
        if (msg.replyTo && (msg.replyTo.messageId || msg.replyTo.id)) {
            const replyToId = msg.replyTo.messageId || msg.replyTo.id;
            
            const replyInfo = document.createElement('div');
            replyInfo.className = 'reply-info';
            replyInfo.dataset.replyToId = replyToId;
            
            // Add click event to scroll to original message
            replyInfo.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Reply clicked, target ID:', replyToId);
                if (typeof scrollToOriginalMessage === 'function') {
                    scrollToOriginalMessage(replyToId);
                }
            });
            
            // Add a reply icon
            const replyIcon = document.createElement('span');
            replyIcon.className = 'reply-icon';
            replyIcon.innerHTML = '‚Ü© ';
            replyIcon.style.color = '#f218d9';
            replyIcon.style.marginRight = '4px';
            replyIcon.style.fontWeight = 'bold';
            replyInfo.appendChild(replyIcon);
            
            const replyUsername = document.createElement('span');
            replyUsername.className = 'reply-username';
            replyUsername.textContent = msg.replyTo.username || "Unknown user";
            
            const replyText = document.createElement('span');
            replyText.className = 'reply-text';
            replyText.textContent = msg.replyTo.text || 'Media message';
            
            replyInfo.appendChild(replyUsername);
            replyInfo.appendChild(replyText);
            textSpan.appendChild(replyInfo);
            
            messageElement.dataset.isReply = "true";
            messageElement.classList.add('has-reply');
        }
        
        // Handle media
        if (msg.media && typeof msg.media === 'object' && msg.media.url) {
            const mediaElement = createMediaElement(msg.media);
            if (mediaElement) {
                textSpan.appendChild(mediaElement);
            }
        }
        
        // Add text content
        if (msg.text && msg.text.trim()) {
            const textNode = document.createElement('span');
            textNode.innerHTML = formatMessageText(msg.text);
            textSpan.appendChild(textNode);
        }
        
        messageElement.appendChild(textSpan);
        
        // Add reactions if present
        if (msg.reactions && msg.reactions.length > 0) {
            if (typeof updateReactions === 'function') {
                updateReactions(messageElement, msg.reactions);
            } else if (typeof window.updateReactions === 'function') {
                window.updateReactions(messageElement, msg.reactions);
            }
        }
        
        messageContent.appendChild(messageElement);
        
        messageWrapper.appendChild(profilePic);
        messageWrapper.appendChild(messageContent);
        messageContainer.appendChild(messageWrapper);
        
        messagesContainer.appendChild(messageContainer);
        
        // Update for grouping
        lastMessageSender = currentSender;
        lastMessageTime = currentTime;
        lastMessageWrapper = messageWrapper;
        
        // Only scroll if needed
        if (!noScroll) {
            scrollToBottom();
        }
    }

    // Function to add a system message
    function addSystemMessage(text, targetContainer = null) {
        // Create a system message element
        const systemMessage = document.createElement('div');
        systemMessage.className = 'system-message';
        
        // Sanitize the text to prevent XSS attacks but preserve emoticons
        const sanitizedText = sanitizeWithEmoticons(text);
        
        systemMessage.innerHTML = sanitizedText;
        
        // Add to the specified container or default messagesContainer
        (targetContainer || messagesContainer).appendChild(systemMessage);
        
        // Only scroll to bottom if we're not using a fragment
        if (!targetContainer) {
            scrollToBottom();
        }
    }

    // Function to format time
    function formatTime(date) {
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        return `${hours}:${minutes}`;
    }

    // Function to scroll to the bottom of messages
    function scrollToBottom(smooth = true) {
        if (!smooth) {
            messagesContainer.classList.add('loading-messages-no-scroll');
        }
        
        // Use requestAnimationFrame to ensure the DOM has updated
        requestAnimationFrame(() => {
            // Ensure we're at the very bottom by using a large value
            messagesContainer.scrollTop = messagesContainer.scrollHeight + 1000;
            
            // Re-enable smooth scrolling after a short delay if it was disabled
            if (!smooth) {
                setTimeout(() => {
                    messagesContainer.classList.remove('loading-messages-no-scroll');
                }, 50);
            }
        });
    }

    // Initialize emoji picker
    let picker = null;
    let isPickerVisible = false;

    // Initialize emoji picker
    function initializeEmojiPicker() {
        try {
            const container = document.createElement('div');
            container.className = 'emoji-picker-container';
            
            // Create category tabs
            const tabsContainer = document.createElement('div');
            tabsContainer.className = 'emoji-tabs';
            
            // Create emoji grid
            const gridContainer = document.createElement('div');
            gridContainer.className = 'emoji-grid-container';
            
            // Add category tabs
            Object.keys(emojiCategories).forEach(category => {
                const tab = document.createElement('button');
                tab.className = 'emoji-tab';
                tab.innerHTML = `${categoryIcons[category]} <span>${category.charAt(0).toUpperCase() + category.slice(1)}</span>`;
                tab.onclick = () => showEmojiCategory(category, gridContainer);
                tabsContainer.appendChild(tab);
            });
            
            container.appendChild(tabsContainer);
            container.appendChild(gridContainer);
            
            // Clear any existing content
            emojiPicker.innerHTML = '';
            emojiPicker.appendChild(container);
            
            // Show first category by default
            showEmojiCategory('smileys', gridContainer);
            
        } catch (error) {
            console.error('Error initializing emoji picker:', error);
        }
    }

    // Show emoji category
    function showEmojiCategory(category, container) {
        // Update active tab
        const tabs = document.querySelectorAll('.emoji-tab');
        tabs.forEach(tab => {
            tab.classList.remove('active');
            if (tab.textContent.toLowerCase() === category) {
                tab.classList.add('active');
            }
        });
        
        // Clear and populate grid
        container.innerHTML = '';
        
        const emojis = emojiCategories[category];
        emojis.forEach(emoji => {
            const button = document.createElement('button');
            button.className = 'emoji-button';
            button.textContent = emoji;
            button.onclick = () => {
                insertEmoji(emoji);
                toggleEmojiPicker();
            };
            container.appendChild(button);
        });
    }

    // Toggle emoji picker visibility
    function toggleEmojiPicker() {
        if (emojiPicker.style.display === 'block') {
            emojiPicker.style.display = 'none';
        } else {
                initializeEmojiPicker();
            
            // Position the emoji picker
            const inputRect = messageInput.getBoundingClientRect();
            emojiPicker.style.bottom = (window.innerHeight - inputRect.top + 10) + 'px';
            emojiPicker.style.left = (inputRect.left + inputRect.width / 2 - 200) + 'px';
            
            emojiPicker.style.display = 'block';
        }
    }

    // Insert emoji into message input
    function insertEmoji(emoji) {
        const start = messageInput.selectionStart;
        const end = messageInput.selectionEnd;
        const text = messageInput.value;
        messageInput.value = text.substring(0, start) + emoji + text.substring(end);
        messageInput.selectionStart = messageInput.selectionEnd = start + emoji.length;
        messageInput.focus();
    }

    // Handle file attachment
    if (attachmentButton) {
    attachmentButton.addEventListener('click', () => {
        fileInput.click();
    });
    }

    // Handle file input
    if (fileInput) {
        fileInput.addEventListener('change', function() {
            handleFileUpload(this.files[0]);
        });
    }

    // Function to create media element
    function createMediaElement(media) {
        // Check if media object is valid and has a URL
        if (!media || typeof media !== 'object' || !media.url) {
            // Remove console warning that's causing log spam
            // Return an empty div instead of logging an error
            return document.createElement('div');
        }
        
        const container = document.createElement('div');
        container.className = 'media-container';
        container.style.border = 'none';
        container.style.outline = 'none';
        container.style.boxShadow = 'none';
        container.style.background = 'transparent';
        
        let mediaElement;
        
        // Check if media.type exists before using startsWith
        if (media.type && typeof media.type === 'string') {
            if (media.type.startsWith('image/')) {
                mediaElement = document.createElement('img');
                mediaElement.src = media.url;
                mediaElement.alt = 'Image';
                mediaElement.style.maxWidth = '100%';
                mediaElement.style.maxHeight = '400px';
                mediaElement.style.objectFit = 'contain';
                mediaElement.style.border = 'none';
                mediaElement.style.outline = 'none';
                mediaElement.style.boxShadow = 'none';
            } else if (media.type.startsWith('video/')) {
                mediaElement = document.createElement('video');
                mediaElement.src = media.url;
                mediaElement.controls = true;
                mediaElement.style.maxWidth = '100%';
                mediaElement.style.maxHeight = '400px';
                mediaElement.style.objectFit = 'contain';
                mediaElement.style.border = 'none';
                mediaElement.style.outline = 'none';
                mediaElement.style.boxShadow = 'none';
            }
        } else {
            // If media.type is missing, try to guess from URL
            const url = media.url.toLowerCase();
            if (url.endsWith('.jpg') || url.endsWith('.jpeg') || url.endsWith('.png') || 
                url.endsWith('.gif') || url.endsWith('.webp')) {
                mediaElement = document.createElement('img');
                mediaElement.src = media.url;
                mediaElement.alt = 'Image';
                mediaElement.style.maxWidth = '100%';
                mediaElement.style.maxHeight = '400px';
                mediaElement.style.objectFit = 'contain';
                mediaElement.style.border = 'none';
                mediaElement.style.outline = 'none';
                mediaElement.style.boxShadow = 'none';
            } else if (url.endsWith('.mp4') || url.endsWith('.webm') || url.endsWith('.ogg')) {
                mediaElement = document.createElement('video');
                mediaElement.src = media.url;
                mediaElement.controls = true;
                mediaElement.style.maxWidth = '100%';
                mediaElement.style.maxHeight = '400px';
                mediaElement.style.objectFit = 'contain';
                mediaElement.style.border = 'none';
                mediaElement.style.outline = 'none';
                mediaElement.style.boxShadow = 'none';
            } else {
                // Create a link if we can't determine the type
                mediaElement = document.createElement('a');
                mediaElement.href = media.url;
                mediaElement.target = '_blank';
                mediaElement.textContent = media.name || 'View Media';
                mediaElement.className = 'media-link';
            }
        }
        
        if (mediaElement) {
            container.appendChild(mediaElement);
            
            // Add media actions
            const actions = document.createElement('div');
            actions.className = 'media-actions';
            
            const downloadBtn = document.createElement('button');
            downloadBtn.className = 'download-btn';
            downloadBtn.innerHTML = '<i class="bi bi-download"></i>';
            downloadBtn.onclick = () => window.open(media.url, '_blank');
            
            const expandBtn = document.createElement('button');
            expandBtn.className = 'expand-btn';
            expandBtn.innerHTML = '<i class="bi bi-arrows-fullscreen"></i>';
            expandBtn.onclick = () => window.open(media.url, '_blank');
            
            actions.appendChild(downloadBtn);
            actions.appendChild(expandBtn);
            container.appendChild(actions);
        }
        
        return container;
    }

    // Function to handle file uploads
    function handleFileUpload(file) {
        if (!file) return;

        // Check file size (5MB limit)
        if (file.size > 5 * 1024 * 1024) {
            notifications.error('File Too Large', 'Maximum file size is 5MB');
            return;
        }

        // Check file type
        if (!file.type.startsWith('image/') && !file.type.startsWith('video/')) {
            notifications.error('Invalid File Type', 'Only images, GIFs, and videos are allowed');
            return;
        }

        // Create and show upload progress
        const progress = createUploadProgress();
        const progressFill = progress.querySelector('.upload-progress-fill');
        const progressInfo = progress.querySelector('.upload-info');
        const preview = progress.querySelector('.upload-preview');

        // Show preview
        if (file.type.startsWith('image/')) {
            const img = document.createElement('img');
            img.src = URL.createObjectURL(file);
            img.style.maxWidth = '100%';
            img.style.maxHeight = '100%';
            img.style.objectFit = 'contain';
            preview.appendChild(img);
        } else if (file.type.startsWith('video/')) {
            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.controls = true;
            video.style.maxWidth = '100%';
            video.style.maxHeight = '100%';
            video.style.objectFit = 'contain';
            preview.appendChild(video);
        }

        try {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('username', username);

            const xhr = new XMLHttpRequest();
            xhr.open('POST', '/upload-media', true);

            // Track upload progress
            xhr.upload.onprogress = (event) => {
                if (event.lengthComputable) {
                    const percentComplete = (event.loaded / event.total) * 100;
                    progressFill.style.width = percentComplete + '%';
                    progressInfo.textContent = Math.round(percentComplete) + '%';
                }
            };

            xhr.onload = () => {
                if (xhr.status === 200) {
                    const data = JSON.parse(xhr.responseText);
                    socket.emit('chat message', {
                        text: messageInput.value.trim(),
                        media: {
                            url: data.url,
                            type: data.type,
                            name: file.name
                        }
                    });

                    messageInput.value = '';
                    messageInput.style.height = 'auto';
                    messageInput.focus();
                } else {
                    notifications.error('Upload Failed', 'Failed to upload media');
                }
                progress.remove();
            };

            xhr.onerror = () => {
                notifications.error('Upload Failed', 'Failed to upload media');
                progress.remove();
            };

            xhr.send(formData);
        } catch (error) {
            console.error('Upload error:', error);
            notifications.error('Upload Failed', 'Failed to upload media');
            progress.remove();
        }
    }

    // Create upload progress element
    function createUploadProgress() {
        const progress = document.createElement('div');
        progress.className = 'upload-progress';
        progress.innerHTML = `
            <div class="upload-progress-header">
                <h3 class="upload-progress-title">Uploading Media</h3>
                <button class="upload-progress-close">
                    <i class="bi bi-x"></i>
                </button>
            </div>
            <div class="upload-progress-bar">
                <div class="upload-progress-fill"></div>
            </div>
            <div class="upload-preview"></div>
            <p class="upload-info">0%</p>
        `;
        
        // Add close button functionality
        const closeBtn = progress.querySelector('.upload-progress-close');
        closeBtn.onclick = () => {
            progress.remove();
        };
        
        document.body.appendChild(progress);
        return progress;
    }

    // Function to update online status in message containers
    function updateOnlineStatusInMessages(specificUsername = null) {
        const messageContainers = document.querySelectorAll('.message-container');
        
        messageContainers.forEach(container => {
            const username = container.dataset.username;
            
            // If we only want to update a specific user, skip others
            if (specificUsername && username !== specificUsername) {
                return;
            }
            
            // Skip user's own messages
            if (username === localStorage.getItem('username')) {
                return;
            }
            
            // Only proceed if we have a username
            if (!username) return;
            
            const profilePic = container.querySelector('.message-profile-pic');
            if (!profilePic) return;
            
            // Remove existing indicator if any
            const existingIndicator = profilePic.querySelector('.online-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
            
            // Add indicator if user is online
            if (onlineUsers.has(username)) {
                const indicator = document.createElement('div');
                indicator.className = 'online-indicator';
                profilePic.appendChild(indicator);
            }
        });
    }

    // Helper function to check if a message is short
    function isShortMessage(text) {
        if (!text) return true;
        const trimmedText = text.trim();
        return trimmedText.length <= 30 && !trimmedText.includes('\n');
    }

    // Format timestamp for display
    function formatTimestamp(date) {
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        return `${hours}:${minutes}`;
    }

    // Initialize emoji picker
    initializeEmojiPicker();

    // Function to create message actions menu (reply/react)
    function createMessageActions(messageElement, msg) {
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'message-actions';
        
        // Reply button
        const replyButton = document.createElement('button');
        replyButton.className = 'action-button reply-btn';
        replyButton.innerHTML = '<i class="bi bi-reply"></i>';
        replyButton.title = 'Reply';
        replyButton.addEventListener('click', function(e) {
            e.stopPropagation();
            setupReply(msg);
        });
        actionsDiv.appendChild(replyButton);
        
        // React button
        const reactButton = document.createElement('button');
        reactButton.className = 'action-button react-btn';
        reactButton.innerHTML = '<i class="bi bi-emoji-smile"></i>';
        reactButton.title = 'React';
        reactButton.addEventListener('click', function(e) {
            e.stopPropagation();
            // Check if the message has a valid ID before showing the reaction menu
            if (msg._id) {
                showReactionMenu(e, msg._id);
            } else {
                console.error("Cannot react to message: missing message ID");
                // Optional: show a notification to the user
                if (typeof notifications !== 'undefined') {
                    notifications.error('Error', 'Cannot react to this message');
                }
            }
        });
        actionsDiv.appendChild(reactButton);
        
        return actionsDiv;
    }
    
    // Function to show the reaction menu
    function showReactionMenu(event, messageId) {
        // Log the messageId for debugging
        console.log("Showing reaction menu for message ID:", messageId);
        
        // Verify messageId is not undefined
        if (!messageId) {
            console.error("Cannot show reaction menu: messageId is undefined");
            return;
        }
        
        // Ensure the reaction menu exists
        if (!reactionMenu || !document.body.contains(reactionMenu)) {
            console.error('Reaction menu element not found or not in document. Creating it now.');
            // Create the menu element if it doesn't exist
            const newReactionMenu = document.createElement('div');
            newReactionMenu.className = 'reaction-menu';
            newReactionMenu.innerHTML = `
                <div class="reaction-emoji-list">
                    <span class="reaction-emoji" data-emoji="üëç">üëç</span>
                    <span class="reaction-emoji" data-emoji="‚ù§Ô∏è">‚ù§Ô∏è</span>
                    <span class="reaction-emoji" data-emoji="üòÇ">üòÇ</span>
                    <span class="reaction-emoji" data-emoji="üòÆ">üòÆ</span>
                    <span class="reaction-emoji" data-emoji="üò¢">üò¢</span>
                    <span class="reaction-emoji" data-emoji="üëè">üëè</span>
                    <span class="reaction-emoji" data-emoji="üî•">üî•</span>
                    <span class="reaction-emoji" data-emoji="üôè">üôè</span>
                </div>
            `;
            document.body.appendChild(newReactionMenu);
            
            // Add event listeners to reaction emojis
            newReactionMenu.querySelectorAll('.reaction-emoji').forEach(emoji => {
                emoji.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const menuMessageId = newReactionMenu.dataset.messageId;
                    
                    // Verify messageId is not undefined
                    if (!menuMessageId) {
                        console.error("Cannot send reaction: missing messageId");
                        if (typeof notifications !== 'undefined') {
                            notifications.error('Error', 'Cannot react to this message');
                        }
                        closeReactionMenu();
                        return;
                    }
                    
                    console.log("Sending reaction for message ID:", menuMessageId);
                    const emojiValue = this.dataset.emoji;
                    
                    // Send the reaction to the server
                    socket.emit('message reaction', {
                        messageId: menuMessageId,
                        emoji: emojiValue
                    });
                    
                    // Close the menu
                    closeReactionMenu();
                });
            });
            
            // Update the reactionMenu reference
            reactionMenu = newReactionMenu;
        }
        
        // Get the message element itself for better positioning
        const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
        if (!messageElement) {
            console.error('Message element not found for ID:', messageId);
            return;
        }
        
        // Position the menu with respect to viewport boundaries
        const messageRect = messageElement.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const viewportWidth = window.innerWidth;
        
        // Determine if it's the user's own message
        const isOwnMessage = messageElement.classList.contains('message-own');
        
        // Default positioning
        let top = messageRect.top + (messageRect.height / 2);
        
        // For own messages (left side), position on the left
        // For other messages (right side), position on the right
        let left;
        if (isOwnMessage) {
            left = messageRect.left - 40; // Position to the left of user's messages
            if (left < 60) left = 60; // Prevent from going off-screen
        } else {
            left = messageRect.right + 40; // Position to the right of other's messages
            if (left > viewportWidth - 60) left = viewportWidth - 60; // Prevent from going off-screen
        }
        
        // If message is near the top of the viewport, position the menu below
        if (top < 80) {
            top = 80; // Keep menu from going off top edge
        } else if (top > viewportHeight - 80) {
            top = viewportHeight - 80; // Keep menu from going off bottom edge
        }
        
        // Apply positioning
        reactionMenu.style.top = `${top}px`;
        reactionMenu.style.left = `${left}px`;
        reactionMenu.style.transform = 'none'; // Remove the horizontal centering transform
        reactionMenu.style.display = 'block';
        
        // Store the message ID as a data attribute
        reactionMenu.dataset.messageId = messageId;
        
        // Add click event to document to close menu when clicking elsewhere
        document.addEventListener('click', closeReactionMenu);
        
        // Prevent the click from immediately closing the menu
        event.stopPropagation();
    }
    
    // Function to close the reaction menu
    function closeReactionMenu() {
        if (reactionMenu) {
            reactionMenu.style.display = 'none';
            if (reactionMenu.dataset) {
                reactionMenu.dataset.messageId = '';
            }
        }
        document.removeEventListener('click', closeReactionMenu);
    }
    
    // Function to create or update reaction badges for a message
    function updateReactions(messageElement, reactions) {
        // Find or create the reactions container
        let reactionsContainer = messageElement.querySelector('.message-reactions');
        
        // If no reactions, remove the container if it exists and return
        if (!reactions || reactions.length === 0) {
            if (reactionsContainer) {
                reactionsContainer.remove();
            }
            return;
        }
        
        // Create a new reactions container if it doesn't exist or recreate it to ensure correct positioning
        if (reactionsContainer) {
            reactionsContainer.remove();
        }
        
        // Create fresh reactions container
        reactionsContainer = document.createElement('div');
        reactionsContainer.className = 'message-reactions';
        
        // Group reactions by emoji
        const emojiCounts = {};
        reactions.forEach(reaction => {
            if (!emojiCounts[reaction.emoji]) {
                emojiCounts[reaction.emoji] = {
                    count: 0,
                    usernames: [],
                    userReacted: false
                };
            }
            emojiCounts[reaction.emoji].count++;
            
            const reactionUser = reaction.username || reaction.sender || 'Unknown';
            emojiCounts[reaction.emoji].usernames.push(reactionUser);
            
            // Check if current user reacted
            if (reactionUser === username) {
                emojiCounts[reaction.emoji].userReacted = true;
            }
        });
        
        // Create badge for each emoji reaction
        for (const emoji in emojiCounts) {
            const badge = document.createElement('span');
            badge.className = 'reaction-badge';
            if (emojiCounts[emoji].userReacted) {
                badge.classList.add('user-reacted');
            }
            
            // Set title with usernames who reacted
            const usersList = emojiCounts[emoji].usernames.map(name => 
                name === username ? 'You' : name
            ).join(', ');
            badge.title = `${usersList} reacted with ${emoji}`;
            
            // Add emoji and count
            badge.innerHTML = `
                ${emoji} <span class="reaction-count">${emojiCounts[emoji].count}</span>
            `;
            
            // Add click handler to toggle reaction
            badge.addEventListener('click', function() {
                socket.emit('message reaction', {
                    messageId: messageElement.dataset.messageId,
                    emoji: emoji
                });
            });
            
            reactionsContainer.appendChild(badge);
        }
        
        // Position the reactions container after the message text but before the timestamp
        const messageText = messageElement.querySelector('.message-text');
        const timestamp = messageElement.querySelector('.message-time');
        
        // Ensure correct DOM ordering for flexbox to work
        if (messageText && messageText.nextSibling) {
            // If there's a sibling after message text, insert before it
            messageElement.insertBefore(reactionsContainer, messageText.nextSibling);
        } else if (timestamp) {
            // If there's a timestamp, insert before it
            messageElement.insertBefore(reactionsContainer, timestamp);
        } else {
            // If neither conditions apply, just append at the end
            messageElement.appendChild(reactionsContainer);
        }
    }
    
    // Socket.io event handlers
    socket.on('message reaction update', function(data) {
        // Add a small delay to ensure DOM is ready
        setTimeout(() => {
            // Find the message element
            const messageElement = document.querySelector(`[data-message-id="${data.messageId}"]`);
            if (messageElement) {
                // Update reactions
                updateReactions(messageElement, data.reactions);
            } else {
                console.error('Message element not found for reaction update:', data.messageId);
                
                // Debug: log available message elements
                const elements = document.querySelectorAll('[data-message-id]');
                console.log(`Found ${elements.length} elements with data-message-id, looking for ${data.messageId}`);
            }
        }, 50); // Small delay for DOM to be ready
    });

    // Add event listeners to reaction emojis
    reactionMenu.querySelectorAll('.reaction-emoji').forEach(emoji => {
        emoji.addEventListener('click', function() {
            const messageId = reactionMenu.dataset.messageId;
            
            // Verify messageId is not undefined
            if (!messageId) {
                console.error("Cannot send reaction: messageId is undefined");
                if (typeof notifications !== 'undefined') {
                    notifications.error('Error', 'Cannot react to this message');
                }
                closeReactionMenu();
                return;
            }
            
            console.log("Sending reaction for message ID:", messageId);
            const emojiValue = this.dataset.emoji;
            
            // Find the message element for immediate UI update
            const messageElement = document.querySelector(`.message[data-message-id="${messageId}"]`);
            
            if (messageElement) {
                // Get current reactions from the element's dataset
                let currentReactions = [];
                if (messageElement.dataset.reactions) {
                    try {
                        currentReactions = JSON.parse(messageElement.dataset.reactions);
                    } catch (e) {
                        console.error("Error parsing existing reactions:", e);
                        currentReactions = [];
                    }
                }
                
                // Toggle the reaction (add if not exists, remove if exists)
                const existingIndex = currentReactions.findIndex(r => 
                    r.emoji === emojiValue && r.username === username
                );
                
                if (existingIndex >= 0) {
                    // Remove existing reaction
                    currentReactions.splice(existingIndex, 1);
                } else {
                    // Add new reaction
                    currentReactions.push({
                        emoji: emojiValue,
                        username: username,
                        timestamp: new Date()
                    });
                }
                
                // Update the dataset with modified reactions
                messageElement.dataset.reactions = JSON.stringify(currentReactions);
                
                // Update message structure to ensure proper order
                // 1. Get the message text and timestamp
                const messageText = messageElement.querySelector('.message-text');
                const timestamp = messageElement.querySelector('.message-time');
                
                // 2. Ensure proper DOM structure: text -> reactions -> timestamp
                updateReactions(messageElement, currentReactions);
            }
            
            // Send the reaction to the server
            socket.emit('message reaction', {
                messageId: messageId,
                emoji: emojiValue
            });
            
            // Close the menu
            closeReactionMenu();
        });
    });

    // Function to scroll to original message that was replied to
    function scrollToOriginalMessage(messageId) {
        if (!messageId) return;
        
        console.log(`Attempting to scroll to original message with ID: ${messageId}`);
        
        // Find the message element by its message ID
        const originalMessageElement = document.querySelector(`[data-message-id="${messageId}"]`);
        if (!originalMessageElement) {
            console.log(`Original message with ID ${messageId} not found in the current chat`);
            if (typeof notifications !== 'undefined') {
                notifications.info('Message Not Found', 'The original message may have been deleted or is not in the current view');
            }
            return;
        }
        
        // Get the parent container
        const messageContainer = originalMessageElement.closest('.message-container');
        if (!messageContainer) return;
        
        // Scroll the message into view with a small offset from the top
        const scrollContainer = messagesContainer;
        const offset = 80; // pixels from the top
        const containerRect = scrollContainer.getBoundingClientRect();
        const messageRect = messageContainer.getBoundingClientRect();
        
        // Calculate scroll position
        const scrollPosition = messageContainer.offsetTop - scrollContainer.offsetTop - offset;
        
        // Smooth scroll to the message
        scrollContainer.scrollTo({
            top: scrollPosition,
            behavior: 'smooth'
        });
        
        // Add highlight effect
        originalMessageElement.classList.add('highlight-message');
        
        // Remove highlight after animation completes
        setTimeout(() => {
            originalMessageElement.classList.remove('highlight-message');
        }, 2000);
    }
}); 